"""
Chat Service - ì‹¤ì‹œê°„ ì±„íŒ… ì„œë¹„ìŠ¤

WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ ë©”ì‹œì§€ ì†¡ìˆ˜ì‹ 
ì½˜í…ì¸  í•„í„°ë§ ë° ìš´ì„¸ ê´€ë ¨ ëŒ€í™” ìœ ë„
Live2D ìºë¦­í„°ì™€ì˜ ìƒí˜¸ì‘ìš© ê´€ë¦¬
"""

import asyncio
import json
import uuid
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum
import logging

from sqlalchemy.orm import Session
from fastapi import WebSocket, WebSocketDisconnect

from ..models.chat import ChatSession, ChatMessage
from ..services.fortune_service import FortuneService
from ..security.content_filter import ContentFilter, FilterResult
from .cache_service import CacheService

logger = logging.getLogger(__name__)




class MessageIntent(str, Enum):
    """ë©”ì‹œì§€ ì˜ë„ ë¶„ë¥˜"""
    FORTUNE_REQUEST = "fortune_request"
    DAILY_FORTUNE = "daily_fortune"
    TAROT_FORTUNE = "tarot_fortune"
    ZODIAC_FORTUNE = "zodiac_fortune"
    ORIENTAL_FORTUNE = "oriental_fortune"
    GREETING = "greeting"
    CASUAL_CHAT = "casual_chat"
    QUESTION = "question"
    COMPLIMENT = "compliment"
    INAPPROPRIATE = "inappropriate"
    UNKNOWN = "unknown"




class ChatService:
    """ì±„íŒ… ì„œë¹„ìŠ¤"""
    
    def __init__(self, database_service = None, cache_service: CacheService = None, 
                 live2d_service = None, fortune_service: FortuneService = None):
        self.database_service = database_service
        self.cache_service = cache_service 
        self.live2d_service = live2d_service
        self.fortune_service = fortune_service
        self.content_filter = ContentFilter()
        
        # í™œì„± ì—°ê²° ê´€ë¦¬
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        self.session_data: Dict[str, Dict[str, Any]] = {}
        self.connection_heartbeats: Dict[str, Dict[WebSocket, datetime]] = {}
        self.heartbeat_interval = 30  # 30 seconds
        self.connection_timeout = 300  # 5 minutes
        
        # LLM ì´ˆê¸°í™” ìƒíƒœ
        self._initialized = False
        
        # Cerebras client ì´ˆê¸°í™”
        self.cerebras_client = None
        self._init_cerebras_client()
    
    async def initialize(self):
        """ì„œë¹„ìŠ¤ ì´ˆê¸°í™”"""
        if self._initialized:
            return
        
        # FortuneService ì§€ì—° ì´ˆê¸°í™”
        if not self.fortune_service:
            from .fortune_service import FortuneService
            self.fortune_service = FortuneService(self.database_service, self.cache_service)
            await self.fortune_service.initialize()
        
        # Live2DService ì§€ì—° ì´ˆê¸°í™”
        if not self.live2d_service:
            from .live2d_service import Live2DService  
            self.live2d_service = Live2DService(self.database_service, self.cache_service)
            await self.live2d_service.initialize()
        
        self._initialized = True
    
    def _init_cerebras_client(self):
        """Cerebras client ì´ˆê¸°í™”"""
        try:
            import os
            from cerebras.cloud.sdk import Cerebras
            
            api_key = os.getenv("CEREBRAS_API_KEY")
            if api_key:
                self.cerebras_client = Cerebras(api_key=api_key)
                logger.info("Cerebras client initialized successfully for chat service")
            else:
                logger.warning("CEREBRAS_API_KEY not found, LLM features will be limited")
                
        except Exception as e:
            logger.error(f"Failed to initialize Cerebras client: {e}")
            self.cerebras_client = None
    
    async def shutdown(self):
        """ì„œë¹„ìŠ¤ ì¢…ë£Œ"""
        if not self._initialized:
            return
        
        # ëª¨ë“  WebSocket ì—°ê²° ì¢…ë£Œ
        for session_id, connections in self.active_connections.items():
            for websocket in connections:
                try:
                    await websocket.close()
                except Exception:
                    pass
        
        self.active_connections.clear()
        self.session_data.clear()
        self._initialized = False
    
    async def _generate_inappropriate_response(self, websocket: WebSocket = None) -> str:
        """ë¶€ì ì ˆí•œ ì½˜í…ì¸ ì— ëŒ€í•œ LLM ì‘ë‹µ ìƒì„±"""
        try:
            if self.cerebras_client:
                system_prompt = """ë‹¹ì‹ ì€ 'ë¯¸ë¼'ë¼ëŠ” ì¹œê·¼í•œ ì ìˆ ì‚¬ ìºë¦­í„°ì…ë‹ˆë‹¤.
ë¶€ì ì ˆí•œ ë‚´ìš©ì´ ê°ì§€ë˜ì—ˆì„ ë•Œ, ìì—°ìŠ¤ëŸ½ê²Œ ëŒ€í™”ë¥¼ ê¸ì •ì ìœ¼ë¡œ ì „í™˜í•´ì£¼ì„¸ìš”.
- ê³µê²©ì ì´ì§€ ì•Šê³  ì¹œê·¼í•˜ê²Œ ëŒ€ì‘
- ìš´ì„¸ë‚˜ ê¸ì •ì ì¸ ì£¼ì œë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ì „í™˜
- 30ì ì´ë‚´ë¡œ ê°„ê²°í•˜ê²Œ"""
                
                response = self.cerebras_client.chat.completions.create(
                    model="llama3.1-8b",
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": "ë¶€ì ì ˆí•œ ë©”ì‹œì§€"}
                    ],
                    temperature=0.7,
                    max_tokens=100
                )
                
                return response.choices[0].message.content
            else:
                # í´ë°± ì‘ë‹µ
                return "ì•—, ë‹¤ë¥¸ ì´ì•¼ê¸°ë¥¼ í•´ë³¼ê¹Œìš”? ì˜¤ëŠ˜ ìš´ì„¸ê°€ ê¶ê¸ˆí•˜ì‹ ê°€ìš”? ğŸ˜Š"
                
        except Exception as e:
            logger.error(f"Failed to generate inappropriate response: {e}")
            return "ë‹¤ë¥¸ ì£¼ì œë¡œ ì´ì•¼ê¸°í•´ë³´ëŠ” ê²Œ ì–´ë–¨ê¹Œìš”? ìš´ì„¸ë¥¼ ë´ë“œë¦´ê²Œìš”! âœ¨"
    
    # MessageIntent.FORTUNE_REQUEST ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¨ìˆ˜ ì¶”ê°€
    async def _handle_fortune_request_general(self, db: Session, session_id: str,
                                             websocket: WebSocket, user_message: str):
        """ì¼ë°˜ ìš´ì„¸ ìš”ì²­ ì²˜ë¦¬ (êµ¬ì²´ì ì¸ íƒ€ì…ì´ ì—†ëŠ” ê²½ìš°)"""
        try:
            # ê¸°ë³¸ì ìœ¼ë¡œ ì¼ì¼ ìš´ì„¸ë¡œ ì²˜ë¦¬
            await self._handle_fortune_request(db, session_id, websocket, {
                "type": "fortune_request",
                "data": {
                    "fortune_type": "daily",
                    "question": user_message,
                    "additional_info": {}
                }
            })
            
        except Exception as e:
            logger.error(f"Error handling general fortune request: {e}")
            await self._send_error_message(websocket, "ìš´ì„¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _generate_llm_response(self, user_message: str, intent: MessageIntent,
                    "ì˜¤ëŠ˜ì˜ ìš´ì„¸ë¥¼ ë´ë“œë¦´ê²Œìš”! ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”... ğŸ”®",
                    "ì¼ì¼ìš´ì„¸ë¥¼ í™•ì¸í•´ë³´ê³  ìˆì–´ìš”. ê³§ ì•Œë ¤ë“œë¦´ê²Œìš”!",
                    "ì˜¤ëŠ˜ í•˜ë£¨ì˜ ìš´ì„ ì‚´í´ë³´ê³  ìˆì–´ìš”. ê¸°ëŒ€í•´ì£¼ì„¸ìš”!"
                ],
                "emotion": "mystical",
                "motion": "crystal_gaze"
            },
            MessageIntent.TAROT_FORTUNE: {
                "responses": [
                    "íƒ€ë¡œì¹´ë“œë¥¼ ì¤€ë¹„í•˜ê³  ìˆì–´ìš”! ì–´ë–¤ ì§ˆë¬¸ì´ ìˆìœ¼ì‹ ê°€ìš”? ğŸ”®",
                    "ì‹ ë¹„ë¡œìš´ íƒ€ë¡œì˜ í˜ìœ¼ë¡œ ë‹µì„ ì°¾ì•„ë“œë¦´ê²Œìš”. ì§ˆë¬¸ì„ ë§ì”€í•´ì£¼ì„¸ìš”!",
                    "ì¹´ë“œë“¤ì´ ë©”ì‹œì§€ë¥¼ ì „í•˜ê³  ì‹¶ì–´í•´ìš”. ë¬´ì—‡ì´ ê¶ê¸ˆí•˜ì‹ ê°€ìš”?"
                ],
                "emotion": "mystical",
                "motion": "card_draw"
            },
            MessageIntent.ZODIAC_FORTUNE: {
                "responses": [
                    "ë³„ìë¦¬ ìš´ì„¸ë¥¼ ë´ë“œë¦´ê²Œìš”! ì–´ë–¤ ë³„ìë¦¬ì„¸ìš”? â­",
                    "ë³„ë“¤ì´ ì „í•˜ëŠ” ë©”ì‹œì§€ë¥¼ ì½ì–´ë“œë¦´ê²Œìš”. ë³„ìë¦¬ë¥¼ ì•Œë ¤ì£¼ì„¸ìš”!",
                    "ì²œì²´ì˜ ì›€ì§ì„ì„ ì‚´í´ë³´ê³  ìˆì–´ìš”. ë³„ìë¦¬ê°€ ë¬´ì—‡ì¸ê°€ìš”?"
                ],
                "emotion": "mystical",
                "motion": "crystal_gaze"
            },
            MessageIntent.ORIENTAL_FORTUNE: {
                "responses": [
                    "ì‚¬ì£¼ë¥¼ ë´ë“œë¦´ê²Œìš”! ìƒë…„ì›”ì¼ì‹œë¥¼ ì•Œë ¤ì£¼ì‹œë©´ ë” ì •í™•í•´ìš”.",
                    "ë™ì–‘ì˜ ê¹Šì€ ì§€í˜œë¡œ ìš´ëª…ì„ ì½ì–´ë“œë¦´ê²Œìš”. ìƒë…„ì›”ì¼ì„ ë§ì”€í•´ì£¼ì„¸ìš”!",
                    "ì‚¬ì£¼íŒ”ìì— ë‹´ê¸´ ë¹„ë°€ì„ í’€ì–´ë“œë¦´ê²Œìš”. ì–¸ì œ íƒœì–´ë‚˜ì…¨ë‚˜ìš”?"
                ],
                "emotion": "mystical",
                "motion": "special_reading"
            },
            MessageIntent.COMPLIMENT: {
                "responses": [
                    "ê³ ë§ˆì›Œìš”! ë‹¹ì‹ ë„ ì •ë§ ë©‹ì§€ì„¸ìš”! ğŸ˜Š",
                    "ì¹­ì°¬í•´ì£¼ì…”ì„œ ê°ì‚¬í•´ìš”! ê¸°ë¶„ì´ ì¢‹ì•„ì ¸ìš”!",
                    "ì™€! ê·¸ëŸ° ë§ì”€ í•´ì£¼ì‹œë‹ˆ ì •ë§ ê¸°ë»ìš”! âœ¨"
                ],
                "emotion": "joy",
                "motion": "blessing"
            },
            MessageIntent.QUESTION: {
                "responses": [
                    "ê¶ê¸ˆí•œ ê²Œ ìˆìœ¼ì‹œêµ°ìš”! ìš´ì„¸ì™€ ê´€ë ¨ëœ ì§ˆë¬¸ì´ë¼ë©´ ì–¸ì œë“  ë‹µí•´ë“œë¦´ê²Œìš”.",
                    "ì§ˆë¬¸ì´ ìˆìœ¼ì‹œë„¤ìš”! ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”!",
                    "ë‹µí•´ë“œë¦´ ìˆ˜ ìˆëŠ” ê±´ ë„ì™€ë“œë¦´ê²Œìš”. ì–´ë–¤ ê²Œ ê¶ê¸ˆí•˜ì„¸ìš”?"
                ],
                "emotion": "thinking",
                "motion": "thinking_pose"
            },
            MessageIntent.CASUAL_CHAT: {
                "responses": [
                    "ë„¤, ë§ì”€í•´ì£¼ì„¸ìš”! ìš´ì„¸ì™€ ê´€ë ¨ëœ ì´ì•¼ê¸°ë¼ë©´ ë”ìš± ì¢‹ê² ì–´ìš”!",
                    "ì¢‹ì•„ìš”! ì–´ë–¤ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ê³  ì‹¶ìœ¼ì„¸ìš”?",
                    "ëŒ€í™”í•˜ëŠ” ê±¸ ì¢‹ì•„í•´ìš”! ìš´ì„¸ì— ëŒ€í•´ ë” ê¶ê¸ˆí•œ ê±´ ì—†ë‚˜ìš”?"
                ],
                "emotion": "comfort",
                "motion": "thinking_pose"
            },
            "inappropriate": {
                "responses": [
                    "ì£„ì†¡í•´ìš”, ê·¸ëŸ° ì´ì•¼ê¸°ëŠ” í•  ìˆ˜ ì—†ì–´ìš”. ìš´ì„¸ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ë³¼ê¹Œìš”?",
                    "ìŒ... ë‹¤ë¥¸ ì£¼ì œë¡œ ì´ì•¼ê¸°í•˜ë©´ ì¢‹ê² ì–´ìš”. ì˜¤ëŠ˜ ìš´ì„¸ëŠ” ì–´ë– ì‹ ì§€ ê¶ê¸ˆí•´ìš”!",
                    "ê·¸ëŸ° ë‚´ìš©ë³´ë‹¤ëŠ” ê¸ì •ì ì¸ ìš´ì„¸ ì´ì•¼ê¸°ë¥¼ í•´ë´ìš”! ğŸ˜Š"
                ],
                "emotion": "concern",
                "motion": "thinking_pose"
            },
            "error": {
                "responses": [
                    "ì£„ì†¡í•´ìš”, ì ì‹œ ë¬¸ì œê°€ ìˆì—ˆì–´ìš”. ë‹¤ì‹œ ë§ì”€í•´ì£¼ì‹œê² ì–´ìš”?",
                    "ì•—, ë¬´ì–¸ê°€ ì˜ëª»ë˜ì—ˆë„¤ìš”. ë‹¤ì‹œ í•œ ë²ˆ ì‹œë„í•´ì£¼ì„¸ìš”!",
                    "ì‹œìŠ¤í…œì— ì‘ì€ ë¬¸ì œê°€ ìˆì—ˆì–´ìš”. ë‹¤ì‹œ ì´ì•¼ê¸°í•´ë³¼ê¹Œìš”?"
                ],
                "emotion": "concern",
                "motion": "thinking_pose"
            }
        }
    
    async def create_chat_session(self, db: Session, session_id: str,
                                user_uuid: Optional[str] = None) -> Dict[str, Any]:
        """ì±„íŒ… ì„¸ì…˜ ìƒì„±"""
        try:
            # ê¸°ì¡´ ì„¸ì…˜ í™•ì¸
            existing_session = ChatSession.find_by_session_id(db, session_id)
            
            if existing_session and existing_session.is_active:
                # ê¸°ì¡´ í™œì„± ì„¸ì…˜ ë°˜í™˜
                return self._format_session_response(existing_session)
            
            
            # ì±„íŒ… ì„¸ì…˜ ìƒì„±
            chat_session = ChatSession(
                session_id=session_id,
                user_uuid=user_uuid,
                character_name="ë¯¸ë¼",
                is_active=True
            )
            
            db.add(chat_session)
            db.commit()
            
            # ì´ˆê¸° í™˜ì˜ ë©”ì‹œì§€ ìƒì„±
            welcome_message = await self._create_welcome_message(db, session_id)
            
            # ì„¸ì…˜ ë°ì´í„° ì´ˆê¸°í™”
            self.session_data[session_id] = {
                "chat_session": chat_session,
                "user_uuid": user_uuid,
                "last_activity": datetime.now(),
                "message_count": 1,
                "context": {
                    "last_intent": MessageIntent.GREETING,
                    "fortune_requests": 0,
                    "user_preferences": {}
                }
            }
            
            # ì—°ê²° ëª©ë¡ ì´ˆê¸°í™”
            if session_id not in self.active_connections:
                self.active_connections[session_id] = set()
            
            logger.info(f"Chat session created: {session_id}")
            
            response = self._format_session_response(chat_session)
            response["initial_message"] = welcome_message
            
            return response
            
        except Exception as e:
            logger.error(f"Error creating chat session: {e}")
            db.rollback()
            raise
    
    async def connect_websocket(self, session_id: str, websocket: WebSocket, db: Session):
        """WebSocket ì—°ê²° ì²˜ë¦¬"""
        try:
            # ì„œë¹„ìŠ¤ ì´ˆê¸°í™” í™•ì¸ (ì§€ì—° ì´ˆê¸°í™”)
            if not self._initialized:
                # database_service ì„¤ì •
                if not self.database_service:
                    self.database_service = db
                
                await self.initialize()
                logger.info("ChatService initialized for WebSocket connection")
            
            await websocket.accept()
            
            # ì—°ê²° ë“±ë¡
            if session_id not in self.active_connections:
                self.active_connections[session_id] = set()
            
            self.active_connections[session_id].add(websocket)
            
            # í•˜íŠ¸ë¹„íŠ¸ ì¶”ì  ì‹œì‘
            if session_id not in self.connection_heartbeats:
                self.connection_heartbeats[session_id] = {}
            self.connection_heartbeats[session_id][websocket] = datetime.now()
            
            # ì„¸ì…˜ í™•ì¸/ìƒì„±
            if session_id not in self.session_data:
                await self.create_chat_session(db, session_id)
            
            # ì—°ê²° í™•ì¸ ë©”ì‹œì§€
            await self._send_to_websocket(websocket, {
                "type": "connection_established",
                "data": {
                    "session_id": session_id,
                    "character_name": "ë¯¸ë¼",
                    "status": "connected"
                }
            })
            
            logger.info(f"WebSocket connected for session: {session_id}")
            
        except Exception as e:
            logger.error(f"Error connecting websocket: {e}")
            raise
    
    async def disconnect_websocket(self, session_id: str, websocket: WebSocket):
        """WebSocket ì—°ê²° í•´ì œ ì²˜ë¦¬"""
        try:
            # ì—°ê²° ì œê±°
            if session_id in self.active_connections:
                self.active_connections[session_id].discard(websocket)
                
                # ë¹ˆ ì—°ê²° ì„¸íŠ¸ ì •ë¦¬
                if not self.active_connections[session_id]:
                    del self.active_connections[session_id]
            
            # í•˜íŠ¸ë¹„íŠ¸ ì¶”ì  ì œê±°
            if session_id in self.connection_heartbeats:
                self.connection_heartbeats[session_id].pop(websocket, None)
                if not self.connection_heartbeats[session_id]:
                    del self.connection_heartbeats[session_id]
            
            
            logger.info(f"WebSocket disconnected for session: {session_id}")
            
        except Exception as e:
            logger.error(f"Error disconnecting websocket: {e}")
    
    async def update_heartbeat(self, session_id: str, websocket: WebSocket):
        """Update heartbeat timestamp for connection"""
        if session_id in self.connection_heartbeats and websocket in self.connection_heartbeats[session_id]:
            self.connection_heartbeats[session_id][websocket] = datetime.now()
    
    async def cleanup_stale_connections(self):
        """Cleanup connections that haven't sent heartbeat in timeout period"""
        current_time = datetime.now()
        stale_connections = []
        
        for session_id, connections in self.connection_heartbeats.items():
            for websocket, last_heartbeat in connections.items():
                if (current_time - last_heartbeat).total_seconds() > self.connection_timeout:
                    stale_connections.append((session_id, websocket))
        
        for session_id, websocket in stale_connections:
            logger.info(f"Cleaning up stale connection for session: {session_id}")
            await self.disconnect_websocket(session_id, websocket)
    
    async def handle_message(self, db: Session, session_id: str, 
                           websocket: WebSocket, message_data: Dict[str, Any]):
        """ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            # Update heartbeat for any incoming message
            await self.update_heartbeat(session_id, websocket)
            
            message_type = message_data.get("type", "text_input")
            
            if message_type == "text_input":
                await self._handle_text_message(db, session_id, websocket, message_data)
            elif message_type == "chat_message":
                # í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë³´ë‚´ëŠ” chat_message íƒ€ì… ì²˜ë¦¬ (ë°ì´í„° êµ¬ì¡°ê°€ ë‹¤ë¦„)
                await self._handle_chat_message(db, session_id, websocket, message_data)
            elif message_type == "fortune_request":
                await self._handle_fortune_request(db, session_id, websocket, message_data)
            elif message_type == "interrupt":
                await self._handle_interrupt(db, session_id, websocket, message_data)
            elif message_type == "ping":
                # Ping ë©”ì‹œì§€ì— ëŒ€í•œ Pong ì‘ë‹µ
                await self._handle_ping(websocket, message_data)
            else:
                await self._send_error_message(websocket, f"Unknown message type: {message_type}")
                
        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await self._send_error_message(websocket, "ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _handle_text_message(self, db: Session, session_id: str,
                                 websocket: WebSocket, message_data: Dict[str, Any]):
        """í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            user_message = message_data.get("data", {}).get("message", "")
            
            if not user_message:
                await self._send_error_message(websocket, "ë©”ì‹œì§€ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
                return
            
            # ì½˜í…ì¸  í•„í„°ë§
            filter_result = self.content_filter.check_content(user_message)
            
            if filter_result.is_blocked:
                await self._handle_inappropriate_content(db, session_id, websocket, 
                                                       filter_result)
                return
            
            # ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
            user_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="user",
                content=user_message,
                content_type="text",
                metadata=json.dumps({"filter_passed": True})
            )
            db.add(user_chat_message)
            
            # ì˜ë„ ë¶„ë¥˜
            intent = self._classify_message_intent(user_message)
            
            # ì„¸ì…˜ ë°ì´í„° ì—…ë°ì´íŠ¸
            if session_id in self.session_data:
                self.session_data[session_id]["last_activity"] = datetime.now()
                self.session_data[session_id]["message_count"] += 1
                self.session_data[session_id]["context"]["last_intent"] = intent
            
            # ì˜ë„ë³„ ì‘ë‹µ ìƒì„±
            if intent in [MessageIntent.DAILY_FORTUNE, MessageIntent.TAROT_FORTUNE, 
                         MessageIntent.ZODIAC_FORTUNE, MessageIntent.ORIENTAL_FORTUNE]:
                await self._handle_specific_fortune_request(db, session_id, websocket, intent, user_message)
            elif intent == MessageIntent.FORTUNE_REQUEST:
                # ì¼ë°˜ ìš´ì„¸ ìš”ì²­ì€ ì¼ì¼ ìš´ì„¸ë¡œ ì²˜ë¦¬
                await self._handle_fortune_request_general(db, session_id, websocket, user_message)
            else:
                await self._generate_and_send_response(db, session_id, websocket, intent, user_message)
            
            db.commit()
            
        except Exception as e:
            logger.error(f"Error handling text message: {e}")
            db.rollback()
            await self._send_error_message(websocket, "ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _handle_chat_message(self, db: Session, session_id: str,
                                 websocket: WebSocket, message_data: Dict[str, Any]):
        """ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬ (í”„ë¡ íŠ¸ì—”ë“œ chat_message íƒ€ì…ìš©)"""
        try:
            # í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë³´ë‚´ëŠ” êµ¬ì¡°: {type: 'chat_message', message: 'í…ìŠ¤íŠ¸', timestamp: '...'}
            user_message = message_data.get("message", "")
            
            if not user_message:
                await self._send_error_message(websocket, "ë©”ì‹œì§€ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
                return
            
            # ì½˜í…ì¸  í•„í„°ë§
            filter_result = self.content_filter.check_content(user_message)
            
            if filter_result.is_blocked:
                await self._handle_inappropriate_content(db, session_id, websocket, 
                                                       filter_result)
                return
            
            # ì‚¬ìš©ì ë©”ì‹œì§€ ì €ì¥
            user_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="user",
                content=user_message,
                content_type="text",
                metadata=json.dumps({"filter_passed": True, "message_type": "chat_message"})
            )
            db.add(user_chat_message)
            
            # ì˜ë„ ë¶„ë¥˜
            intent = self._classify_message_intent(user_message)
            
            # ì„¸ì…˜ ë°ì´í„° ì—…ë°ì´íŠ¸
            if session_id in self.session_data:
                self.session_data[session_id]["last_activity"] = datetime.now()
                self.session_data[session_id]["message_count"] += 1
                self.session_data[session_id]["context"]["last_intent"] = intent
            
            # ì˜ë„ë³„ ì‘ë‹µ ìƒì„±
            if intent in [MessageIntent.DAILY_FORTUNE, MessageIntent.TAROT_FORTUNE, 
                         MessageIntent.ZODIAC_FORTUNE, MessageIntent.ORIENTAL_FORTUNE]:
                await self._handle_specific_fortune_request(db, session_id, websocket, intent, user_message)
            elif intent == MessageIntent.FORTUNE_REQUEST:
                # ì¼ë°˜ ìš´ì„¸ ìš”ì²­ì€ ì¼ì¼ ìš´ì„¸ë¡œ ì²˜ë¦¬
                await self._handle_fortune_request_general(db, session_id, websocket, user_message)
            else:
                await self._generate_and_send_response(db, session_id, websocket, intent, user_message)
            
            db.commit()
            
        except Exception as e:
            logger.error(f"Error handling chat message: {e}")
            db.rollback()
            await self._send_error_message(websocket, "ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _handle_fortune_request(self, db: Session, session_id: str,
                                    websocket: WebSocket, message_data: Dict[str, Any]):
        """ìš´ì„¸ ìš”ì²­ ì²˜ë¦¬"""
        try:
            fortune_data = message_data.get("data", {})
            fortune_type = fortune_data.get("fortune_type", "daily")
            question = fortune_data.get("question", "")
            additional_info = fortune_data.get("additional_info", {})
            
            # ìš´ì„¸ ìš”ì²­ ì¹´ìš´íŠ¸ ì¦ê°€
            if session_id in self.session_data:
                self.session_data[session_id]["context"]["fortune_requests"] += 1
            
            # ìš´ì„¸ ìƒì„± ì•Œë¦¼
            await self._send_to_websocket(websocket, {
                "type": "fortune_processing",
                "data": {
                    "fortune_type": fortune_type,
                    "message": f"{fortune_type} ìš´ì„¸ë¥¼ ì¤€ë¹„í•˜ê³  ìˆì–´ìš”... ğŸ”®"
                }
            })
            
            
            # AI ìš´ì„¸ ìƒì„± ì‹œë„ (Cerebrasê°€ í™œì„±í™”ëœ ê²½ìš°)
            user_data = self._get_user_data_for_fortune(session_id, additional_info)
            
            # LLM í˜¸ì¶œ ì‹œì‘ ì•Œë¦¼
            await self._send_to_websocket(websocket, {
                "type": "llm_processing",
                "data": {
                    "message": "AIê°€ ìš´ì„¸ë¥¼ ìƒì„±í•˜ê³  ìˆì–´ìš”...",
                    "status": "calling_llm",
                    "fortune_type": fortune_type
                }
            })
            
            # AI ìš´ì„¸ ìƒì„± ì‹œë„
            if hasattr(self.fortune_service, 'use_cerebras') and self.fortune_service.use_cerebras:
                fortune_result = await self._generate_ai_fortune_response(
                    db, fortune_type, question, user_data, additional_info, websocket
                )
            else:
                # ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ í´ë°±
                fortune_result = await self._generate_legacy_fortune_response(
                    db, fortune_type, question, user_data, additional_info
                )
                
            # LLM ì‘ë‹µ ì™„ë£Œ ì•Œë¦¼
            await self._send_to_websocket(websocket, {
                "type": "llm_complete",
                "data": {
                    "message": "AI ìš´ì„¸ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆì–´ìš”!",
                    "status": "llm_complete"
                }
            })
            
            
            # ìš´ì„¸ ê²°ê³¼ ì „ì†¡ (TTS ë° Live2D í†µí•©)
            logger.info(f"Generated fortune result structure: {type(fortune_result)}")
            logger.info(f"Fortune result keys: {fortune_result.keys() if isinstance(fortune_result, dict) else 'Not a dict'}")
            
            # AIì—ì„œ ìƒì„±ëœ ìš´ì„¸ ë©”ì‹œì§€ ì¶”ì¶œ
            logger.info(f"ğŸ” [ë©”ì‹œì§€ ì¶”ì¶œ ì „] fortune_result íƒ€ì…: {type(fortune_result)}")
            logger.info(f"ğŸ” [ë©”ì‹œì§€ ì¶”ì¶œ ì „] fortune_result ë‚´ìš©: {str(fortune_result)[:500]}...")
            
            fortune_message = self._extract_fortune_message(fortune_result, fortune_type)
            
            logger.info(f"ğŸ¤ [ì¶”ì¶œëœ ë©”ì‹œì§€] TTSìš©: {fortune_message[:200]}...")
            
            # Live2D ê°ì • ë° ëª¨ì…˜ ì •ë³´ ì¶”ì¶œ
            live2d_emotion = fortune_result.get("live2d_emotion", "neutral")
            live2d_motion = fortune_result.get("live2d_motion", "crystal_gaze")
            
            # WebSocketìœ¼ë¡œ ìš´ì„¸ ê²°ê³¼ ì „ì†¡ (TTS ë° Live2D í¬í•¨)
            await self._send_to_websocket(websocket, {
                "type": "fortune_result", 
                "data": {
                    "fortune_result": fortune_result,
                    "tts_text": fortune_message,  # TTSìš© ì¶”ì¶œëœ ë©”ì‹œì§€
                    "character_message": fortune_message,  # ìºë¦­í„° ë©”ì‹œì§€ 
                    "live2d_emotion": live2d_emotion,
                    "live2d_motion": live2d_motion,
                    "enable_tts": True,
                    "enable_live2d": True
                }
            })
            
            # ê²°ê³¼ ë©”ì‹œì§€ ì €ì¥
            fortune_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="assistant",
                content=json.dumps(fortune_result, ensure_ascii=False),
                content_type="fortune_result",
                metadata=json.dumps({
                    "fortune_type": fortune_type,
                    "fortune_id": fortune_result.get("fortune_id")
                })
            )
            db.add(fortune_message)
            db.commit()
            
        except Exception as e:
            logger.error(f"Error handling fortune request: {e}")
            db.rollback()
            await self._send_error_message(websocket, "ìš´ì„¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _handle_interrupt(self, db: Session, session_id: str,
                              websocket: WebSocket, message_data: Dict[str, Any]):
        """ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬"""
        try:
            reason = message_data.get("data", {}).get("reason", "user_stop")
            
            
            # ì¤‘ë‹¨ ì‘ë‹µ
            await self._send_to_websocket(websocket, {
                "type": "interrupt_acknowledged",
                "data": {
                    "reason": reason,
                    "message": "ë„¤, ì•Œê² ì–´ìš”. ë‹¤ë¥¸ ì§ˆë¬¸ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ë§ì”€í•´ì£¼ì„¸ìš”!"
                }
            })
            
        except Exception as e:
            logger.error(f"Error handling interrupt: {e}")
            await self._send_error_message(websocket, "ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _handle_ping(self, websocket: WebSocket, message_data: Dict[str, Any]):
        """Ping ë©”ì‹œì§€ ì²˜ë¦¬ - Pong ì‘ë‹µ ì „ì†¡"""
        try:
            timestamp = message_data.get("timestamp", datetime.now().isoformat())
            
            # Pong ì‘ë‹µ ì „ì†¡
            await self._send_to_websocket(websocket, {
                "type": "pong",
                "timestamp": timestamp
            })
            
            logger.debug(f"Ping-Pong handled at {timestamp}")
            
        except Exception as e:
            logger.error(f"Error handling ping: {e}")
            # Ping ì²˜ë¦¬ ì‹¤íŒ¨ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ì§€ ì•ŠìŒ (ì—°ê²° ìƒíƒœ ì²´í¬ìš©ì´ë¯€ë¡œ)
    
    async def _handle_inappropriate_content(self, db: Session, session_id: str,
                                          websocket: WebSocket, filter_result: FilterResult):
        """ë¶€ì ì ˆí•œ ì½˜í…ì¸  ì²˜ë¦¬"""
        try:
            # ë¶€ì ì ˆí•œ ë©”ì‹œì§€ ì €ì¥  
            inappropriate_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="user",
                content="[ë¶€ì ì ˆí•œ ë‚´ìš©ìœ¼ë¡œ í•„í„°ë§ë¨]",
                content_type="system",
                metadata=json.dumps({
                    "filter_category": filter_result.category.value if filter_result.category else "unknown",
                    "filter_reason": filter_result.reason,
                    "confidence": filter_result.confidence
                })
            )
            db.add(inappropriate_message)
            
            # í•„í„°ë§ ì‘ë‹µ - ìƒˆë¡œìš´ ContentFilterì˜ ì œì•ˆ ê¸°ëŠ¥ ì‚¬ìš©
            from ..security.content_filter import get_filter_suggestion
            suggestion_message = get_filter_suggestion(filter_result)
            
            if not suggestion_message:
                # LLMìœ¼ë¡œ ë¶€ì ì ˆí•œ ì½˜í…ì¸ ì— ëŒ€í•œ ì‘ë‹µ ìƒì„±
                suggestion_message = await self._generate_inappropriate_response(websocket)
            
            await self._send_to_websocket(websocket, {
                "type": "content_filtered",
                "data": {
                    "message": suggestion_message,
                    "filter_category": filter_result.category.value if filter_result.category else "inappropriate",
                    "suggestion": "ìš´ì„¸ë‚˜ ê¸ì •ì ì¸ ì´ì•¼ê¸°ë¥¼ í•´ë³¼ê¹Œìš”? ğŸ˜Š"
                }
            })
            
            # ì‘ë‹µ ë©”ì‹œì§€ ì €ì¥
            response_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="assistant",
                content=suggestion_message,
                content_type="text",
                metadata=json.dumps({"response_type": "content_filter"})
            )
            db.add(response_chat_message)
            db.commit()
            
        except Exception as e:
            logger.error(f"Error handling inappropriate content: {e}")
            db.rollback()
    
    async def _handle_specific_fortune_request(self, db: Session, session_id: str,
                                             websocket: WebSocket, intent: MessageIntent,
                                             user_message: str):
        """íŠ¹ì • ìš´ì„¸ ìš”ì²­ ì²˜ë¦¬"""
        try:
            # ì¼ì¼ìš´ì„¸ëŠ” ì„ì‹œ ì‘ë‹µ ì—†ì´ ë°”ë¡œ LLM ì‘ë‹µ ìƒì„±
            if intent == MessageIntent.DAILY_FORTUNE:
                await self._auto_generate_fortune(db, session_id, websocket, "daily", user_message)
                return
            
            # ë‹¤ë¥¸ ìš´ì„¸ íƒ€ì…ë“¤ì€ ì¶”ê°€ ì •ë³´ ìš”ì²­
            if intent == MessageIntent.TAROT_FORTUNE:
                detail_message = "ì–´ë–¤ ì§ˆë¬¸ì´ ìˆìœ¼ì‹ ì§€ êµ¬ì²´ì ìœ¼ë¡œ ë§ì”€í•´ì£¼ì„¸ìš”!"
            elif intent == MessageIntent.ZODIAC_FORTUNE:
                detail_message = "ë³„ìë¦¬ë¥¼ ì•Œë ¤ì£¼ì‹œë©´ ë” ì •í™•í•œ ìš´ì„¸ë¥¼ ë´ë“œë¦´ ìˆ˜ ìˆì–´ìš”!"
            elif intent == MessageIntent.ORIENTAL_FORTUNE:
                detail_message = "ìƒë…„ì›”ì¼ê³¼ íƒœì–´ë‚œ ì‹œê°„ì„ ì•Œë ¤ì£¼ì‹œë©´ ì‚¬ì£¼ë¥¼ ë´ë“œë¦´ê²Œìš”!"
            else:
                # ê¸°ë³¸ì ìœ¼ë¡œ LLM ì‘ë‹µ ìƒì„±
                await self._auto_generate_fortune(db, session_id, websocket, "daily", user_message)
                return
            
            # ì¶”ê°€ ì •ë³´ ìš”ì²­ ë©”ì‹œì§€ ì „ì†¡
            await self._send_to_websocket(websocket, {
                "type": "text_response",
                "data": {
                    "message": detail_message,
                    "is_complete": True,
                    "requires_input": True
                }
            })
            
            # ì‘ë‹µ ë©”ì‹œì§€ ì €ì¥
            response_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="assistant",
                content=detail_message,
                content_type="text",
                metadata=json.dumps({"intent": intent.value})
            )
            db.add(response_chat_message)
            
            db.commit()
            
        except Exception as e:
            logger.error(f"Error handling specific fortune request: {e}")
            db.rollback()
    
    async def _auto_generate_fortune(self, db: Session, session_id: str,
                                   websocket: WebSocket, fortune_type: str,
                                   user_message: str):
        """ìë™ ìš´ì„¸ ìƒì„±"""
        try:
            # ìš´ì„¸ ìš”ì²­ìœ¼ë¡œ ì²˜ë¦¬
            await self._handle_fortune_request(db, session_id, websocket, {
                "type": "fortune_request",
                "data": {
                    "fortune_type": fortune_type,
                    "question": user_message,
                    "additional_info": {}
                }
            })
            
        except Exception as e:
            logger.error(f"Error auto generating fortune: {e}")
            await self._send_error_message(websocket, "ìš´ì„¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
    
    async def _generate_and_send_response(self, db: Session, session_id: str,
                                        websocket: WebSocket, intent: MessageIntent,
                                        user_message: str):
        """ì¼ë°˜ ì‘ë‹µ ìƒì„± ë° ì „ì†¡ (LLM ì‚¬ìš©)"""
        try:
            # LLM í˜¸ì¶œ ì‹œì‘ ì•Œë¦¼
            await self._send_to_websocket(websocket, {
                "type": "llm_processing",
                "data": {
                    "message": "AIê°€ ì‘ë‹µì„ ìƒì„±í•˜ê³  ìˆì–´ìš”...",
                    "status": "calling_llm",
                    "intent": intent.value
                }
            })
            
            # Cerebras LLMì„ ì‚¬ìš©í•œ ì‘ë‹µ ìƒì„±
            response_message = await self._generate_llm_response(user_message, intent, websocket)
            
            # LLM ì‘ë‹µ ì™„ë£Œ ì•Œë¦¼
            await self._send_to_websocket(websocket, {
                "type": "llm_complete",
                "data": {
                    "message": "AI ì‘ë‹µ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆì–´ìš”!",
                    "status": "llm_complete"
                }
            })
            
            # ì‘ë‹µ ì „ì†¡ (fortune_result í˜•ì‹ìœ¼ë¡œ í†µì¼)
            await self._send_to_websocket(websocket, {
                "type": "fortune_result",  # fortune_resultë¡œ í†µì¼í•˜ì—¬ í”„ë¡ íŠ¸ì—”ë“œ ì²˜ë¦¬ ê°„ì†Œí™”
                "data": {
                    "tts_text": response_message,  # TTSìš© ë©”ì‹œì§€
                    "character_message": response_message,  # í‘œì‹œìš© ë©”ì‹œì§€
                    "live2d_emotion": "neutral",
                    "live2d_motion": "idle",
                    "enable_tts": True,
                    "enable_live2d": True,
                    "intent": intent.value
                }
            })
            
            # ì‘ë‹µ ë©”ì‹œì§€ ì €ì¥
            response_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="assistant",
                content=response_message,
                content_type="text",
                metadata=json.dumps({"intent": intent.value, "llm_generated": True})
            )
            db.add(response_chat_message)
            
        except Exception as e:
            logger.error(f"Error generating LLM response: {e}")
            # í´ë°±: í…œí”Œë¦¿ ì‘ë‹µ ì‚¬ìš©
            await self._generate_template_response(db, session_id, websocket, intent)
    
    async def _generate_llm_response(self, user_message: str, intent: MessageIntent, 
                                     websocket: WebSocket = None) -> str:
        """Cerebras LLMì„ ì‚¬ìš©í•œ ì¼ë°˜ ì‘ë‹µ ìƒì„±"""
        try:
            # LLM í˜¸ì¶œ ìƒì„¸ ì •ë³´ ì „ì†¡
            if websocket:
                await self._send_to_websocket(websocket, {
                    "type": "llm_details",
                    "data": {
                        "message": f"Cerebras AIì— ì¼ë°˜ ëŒ€í™” ìš”ì²­ ì¤‘...",
                        "model": "llama3.1-8b",
                        "status": "requesting"
                    }
                })
            
            # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ êµ¬ì„±
            system_prompt = """ë‹¹ì‹ ì€ 'ë¯¸ë¼'ë¼ëŠ” ì´ë¦„ì˜ ì¹œê·¼í•˜ê³  ê·€ì—¬ìš´ ì ìˆ ì‚¬ ìºë¦­í„°ì…ë‹ˆë‹¤.
ë‹¤ìŒ íŠ¹ì§•ì„ ê°€ì§€ê³  ëŒ€í™”í•´ì£¼ì„¸ìš”:
- ì¹œê·¼í•˜ê³  í™œë°œí•œ ì„±ê²©
- ì•½ê°„ ì‹ ë¹„ë¡œìš´ ë¶„ìœ„ê¸°
- ì´ëª¨í‹°ì½˜ ì‚¬ìš© (ì ì ˆíˆ)
- í•œêµ­ì–´ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ëŒ€í™”
- 50ì ì´ë‚´ë¡œ ê°„ê²°í•˜ê²Œ ì‘ë‹µ"""
            
            # ì˜ë„ë³„ í”„ë¡¬í”„íŠ¸ ì¡°ì •
            if intent == MessageIntent.GREETING:
                system_prompt += "\n- ì¹œê·¼í•œ ì¸ì‚¬ì™€ í•¨ê»˜ ê°„ë‹¨í•œ ì•ˆë¶€ë¥¼ ë¬¼ì–´ë³´ì„¸ìš”"
            elif intent == MessageIntent.QUESTION:
                system_prompt += "\n- ì§ˆë¬¸ì— ëŒ€í•´ ë„ì›€ì´ ë˜ëŠ” ë‹µë³€ì„ í•´ì£¼ì„¸ìš”"
            elif intent == MessageIntent.CASUAL_CHAT:
                system_prompt += "\n- ì¼ìƒì ì´ê³  ì¬ë¯¸ìˆëŠ” ëŒ€í™”ë¥¼ ì´ì–´ê°€ì„¸ìš”"
            
            # Cerebras API í˜¸ì¶œ
            if hasattr(self, 'cerebras_client') and self.cerebras_client:
                response = self.cerebras_client.chat.completions.create(
                    model="llama3.1-8b",
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_message}
                    ],
                    temperature=0.8,
                    max_tokens=200
                )
                
                llm_response = response.choices[0].message.content
                logger.info(f"[LLM ì‘ë‹µ] ì¼ë°˜ ëŒ€í™”: {llm_response[:100]}...")
                
                # LLM ì‘ë‹µ ì„±ê³µ ì•Œë¦¼
                if websocket:
                    await self._send_to_websocket(websocket, {
                        "type": "llm_response", 
                        "data": {
                            "message": "Cerebras AI ì‘ë‹µ ë°›ìŒ!",
                            "response_length": len(llm_response),
                            "chat_content": llm_response,
                            "status": "received"
                        }
                    })
                
                return llm_response
                
            else:
                # Cerebras ì‚¬ìš© ë¶ˆê°€ì‹œ ê¸°ë³¸ ì‘ë‹µ
                logger.warning("Cerebras client not available, using template response")
                return await self._get_template_response(intent)
                
        except Exception as e:
            logger.error(f"LLM response generation failed: {e}")
            # ì˜¤ë¥˜ ì‹œ í…œí”Œë¦¿ ì‘ë‹µ ë°˜í™˜
            return await self._get_template_response(intent)
    
    async def _get_template_response(self, intent: MessageIntent) -> str:
        """LLM í´ë°±ìš© ê°„ë‹¨í•œ ì‘ë‹µ ìƒì„±"""
        # LLMì´ ì‹¤íŒ¨í–ˆì„ ë•Œ ì‚¬ìš©í•  ê¸°ë³¸ ì‘ë‹µ
        fallback_responses = {
            MessageIntent.GREETING: "ì•ˆë…•í•˜ì„¸ìš”! ë°˜ê°€ì›Œìš”~ ì˜¤ëŠ˜ í•˜ë£¨ëŠ” ì–´ë– ì…¨ë‚˜ìš”? âœ¨",
            MessageIntent.QUESTION: "í¥ë¯¸ë¡œìš´ ì§ˆë¬¸ì´ë„¤ìš”! ì œê°€ ë„ì™€ë“œë¦´ ìˆ˜ ìˆëŠ” ê²Œ ìˆì„ê¹Œìš”?",
            MessageIntent.CASUAL_CHAT: "ì¬ë¯¸ìˆëŠ” ì´ì•¼ê¸°ë„¤ìš”! ë” ë“¤ë ¤ì£¼ì„¸ìš”~ ğŸ˜Š",
            MessageIntent.FORTUNE_REQUEST: "ìš´ì„¸ê°€ ê¶ê¸ˆí•˜ì‹ ê°€ìš”? ì˜¤ëŠ˜ì˜ ìš´ì„¸ë¥¼ ì•Œë ¤ë“œë¦´ê²Œìš”!",
            MessageIntent.DAILY_FORTUNE: "ì˜¤ëŠ˜ì˜ ìš´ì„¸ë¥¼ í™•ì¸í•´ë“œë¦´ê²Œìš”!",
            MessageIntent.TAROT_FORTUNE: "íƒ€ë¡œ ì¹´ë“œë¥¼ ë½‘ì•„ë“œë¦´ê²Œìš”!",
            MessageIntent.ZODIAC_FORTUNE: "ë³„ìë¦¬ ìš´ì„¸ë¥¼ í™•ì¸í•´ë“œë¦´ê²Œìš”!",
            MessageIntent.ORIENTAL_FORTUNE: "ì‚¬ì£¼ë¥¼ ë´ë“œë¦´ê²Œìš”!"
        }
        
        return fallback_responses.get(intent, "ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ğŸ˜Š")
    
    async def _generate_template_response(self, db: Session, session_id: str,
                                         websocket: WebSocket, intent: MessageIntent):
        """í…œí”Œë¦¿ ê¸°ë°˜ í´ë°± ì‘ë‹µ ìƒì„±"""
        try:
            response_message = await self._get_template_response(intent)
            
            # ì‘ë‹µ ì „ì†¡ (fortune_result í˜•ì‹ìœ¼ë¡œ)
            await self._send_to_websocket(websocket, {
                "type": "fortune_result",
                "data": {
                    "tts_text": response_message,
                    "character_message": response_message,
                    "live2d_emotion": "neutral",
                    "live2d_motion": "idle",
                    "enable_tts": True,
                    "enable_live2d": True,
                    "intent": intent.value,
                    "template_response": True
                }
            })
            
            # ì‘ë‹µ ë©”ì‹œì§€ ì €ì¥
            response_chat_message = ChatMessage(
                message_id=str(uuid.uuid4()),
                session_id=session_id,
                sender_type="assistant",
                content=response_message,
                content_type="text",
                metadata=json.dumps({"intent": intent.value, "template_response": True})
            )
            db.add(response_chat_message)
            
        except Exception as e:
            logger.error(f"Error generating template response: {e}")
            await self._send_error_message(websocket, "ì‘ë‹µ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")

    async def _create_welcome_message(self, db: Session, session_id: str) -> Dict[str, Any]:
        """í™˜ì˜ ë©”ì‹œì§€ ìƒì„±"""
        welcome_text = "ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ë¯¸ë¼ì˜ˆìš”. ì˜¤ëŠ˜ ìš´ì„¸ê°€ ê¶ê¸ˆí•˜ì‹ ê°€ìš”? âœ¨"
        
        welcome_message = ChatMessage(
            message_id=str(uuid.uuid4()),
            session_id=session_id,
            sender_type="assistant",
            content=welcome_text,
            content_type="text",
            metadata=json.dumps({"message_type": "welcome"})
        )
        
        db.add(welcome_message)
        
        return {
            "message": welcome_text,
            "type": "welcome",
            "timestamp": datetime.now().isoformat()
        }
    
    def _get_user_data_for_fortune(self, session_id: str, additional_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """ìš´ì„¸ ìƒì„±ìš© ì‚¬ìš©ì ë°ì´í„° êµ¬ì„±"""
        user_data = {}
        
        # ì„¸ì…˜ ë°ì´í„°ì—ì„œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        if session_id in self.session_data:
            session_info = self.session_data[session_id]
            if session_info.get("user_uuid"):
                user_data["user_uuid"] = session_info["user_uuid"]
            
            # ì‚¬ìš©ì ì„ í˜¸ë„ ì •ë³´
            preferences = session_info.get("context", {}).get("user_preferences", {})
            user_data.update(preferences)
        
        # ì¶”ê°€ ì •ë³´ ë³‘í•©
        user_data.update(additional_info)
        
        return user_data if user_data else None
    
    def _format_session_response(self, chat_session: ChatSession) -> Dict[str, Any]:
        """ì„¸ì…˜ ì‘ë‹µ í¬ë§·"""
        return {
            "session_id": chat_session.session_id,
            "character_name": chat_session.character_name,
            "is_active": chat_session.is_active,
            "created_at": chat_session.created_at.isoformat(),
            "expires_at": (chat_session.created_at + timedelta(hours=24)).isoformat()
        }
    
    def _classify_message_intent(self, message: str) -> MessageIntent:
        """ë©”ì‹œì§€ ì˜ë„ ë¶„ë¥˜"""
        message_lower = message.lower()
        
        # ì¸ì‚¬ í‚¤ì›Œë“œ
        greeting_keywords = [
            "ì•ˆë…•", "ì•ˆë…•í•˜ì„¸ìš”", "ì•ˆë…•í•˜ì‹­ë‹ˆê¹Œ", "ë°˜ê°€ì›Œ", "ë°˜ê°‘ìŠµë‹ˆë‹¤",
            "í•˜ì´", "í—¬ë¡œ", "ì²˜ìŒ", "ë§Œë‚˜ì„œ", "ë°˜ê°€ì›Œìš”", "ì¢‹ì€ì•„ì¹¨",
            "ì¢‹ì€í•˜ë£¨", "ê³ ë§ˆì›Œ", "ê°ì‚¬", "ê³ ë§ˆì›Œìš”", "ê°ì‚¬í•´ìš”", "ê°ì‚¬í•©ë‹ˆë‹¤"
        ]
        
        # ìš´ì„¸ ê´€ë ¨ í‚¤ì›Œë“œ
        fortune_keywords = {
            "daily": ["ì˜¤ëŠ˜", "ì˜¤ëŠ˜ìš´ì„¸", "ì¼ì¼ìš´ì„¸", "í•˜ë£¨", "ì˜¤ëŠ˜ì˜ìš´ì„¸"],
            "tarot": ["íƒ€ë¡œ", "ì¹´ë“œ", "íƒ€ë¡œì¹´ë“œ", "ì ", "ì ë´", "ì¹´ë“œì ", "íƒ€ë¡œì "],
            "zodiac": ["ë³„ìë¦¬", "ë³„ìë¦¬ìš´ì„¸", "ì²œì²´", "í™©ë„", "ì ì„±ìˆ ", "ë³„", "ìë¦¬"],
            "oriental": ["ì‚¬ì£¼", "ì‚¬ì£¼íŒ”ì", "ìš´ëª…", "íŒ”ì", "ì‚¬ì£¼ë´", "ëª…ë¦¬í•™", "ë™ì–‘ì ì„±ìˆ "]
        }
        
        # ì¸ì‚¬ ì²´í¬
        if any(keyword in message_lower for keyword in greeting_keywords):
            return MessageIntent.GREETING
        
        # ìš´ì„¸ ìš”ì²­ ì²´í¬
        for fortune_type, keywords in fortune_keywords.items():
            if any(keyword in message_lower for keyword in keywords):
                if fortune_type == "daily":
                    return MessageIntent.DAILY_FORTUNE
                elif fortune_type == "tarot":
                    return MessageIntent.TAROT_FORTUNE
                elif fortune_type == "zodiac":
                    return MessageIntent.ZODIAC_FORTUNE
                elif fortune_type == "oriental":
                    return MessageIntent.ORIENTAL_FORTUNE
        
        # ì¼ë°˜ì ì¸ ìš´ì„¸ ìš”ì²­
        fortune_general = ["ìš´ì„¸", "ì ", "ì ë´", "ìš´", "ìš´ëª…", "ë¯¸ë˜", "ì•ì¼"]
        if any(keyword in message_lower for keyword in fortune_general):
            return MessageIntent.FORTUNE_REQUEST
        
        # ì§ˆë¬¸
        question_markers = ["?", "ï¼Ÿ", "ë­", "ë¬´ì—‡", "ì–´ë–»", "ì™œ", "ì–¸ì œ", "ì–´ë””"]
        if any(marker in message for marker in question_markers):
            return MessageIntent.QUESTION
        
        # ì¹­ì°¬/ê°íƒ„
        compliment_markers = ["ì˜ˆì˜", "ê·€ì—¬", "ë©‹ì§€", "ì¢‹", "ìµœê³ ", "ì§±", "ëŒ€ë°•"]
        if any(marker in message_lower for marker in compliment_markers):
            return MessageIntent.COMPLIMENT
        
        return MessageIntent.CASUAL_CHAT
    
    async def _send_to_websocket(self, websocket: WebSocket, message: Dict[str, Any]):
        """WebSocketìœ¼ë¡œ ë©”ì‹œì§€ ì „ì†¡"""
        try:
            await websocket.send_text(json.dumps(message, ensure_ascii=False))
        except Exception as e:
            logger.warning(f"Failed to send websocket message: {e}")
    
    async def _send_error_message(self, websocket: WebSocket, error_message: str):
        """ì—ëŸ¬ ë©”ì‹œì§€ ì „ì†¡"""
        await self._send_to_websocket(websocket, {
            "type": "error",
            "data": {
                "error_code": "PROCESSING_ERROR",
                "message": error_message,
                "timestamp": datetime.now().isoformat()
            }
        })
    
    async def get_chat_history(self, db: Session, session_id: str,
                             limit: int = 50) -> List[Dict[str, Any]]:
        """ì±„íŒ… íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
        try:
            messages = ChatMessage.find_session_messages(db, session_id, limit)
            
            return [
                {
                    "id": msg.id,
                    "message_id": msg.message_id,
                    "sender_type": msg.sender_type,
                    "content": msg.content,
                    "content_type": msg.content_type,
                    "metadata": msg.metadata_dict,
                    "created_at": msg.created_at.isoformat()
                }
                for msg in messages
            ]
            
        except Exception as e:
            logger.error(f"Error getting chat history: {e}")
            raise
    
    async def cleanup_inactive_sessions(self, db: Session, hours: int = 24) -> int:
        """ë¹„í™œì„± ì„¸ì…˜ ì •ë¦¬"""
        try:
            cutoff_time = datetime.now() - timedelta(hours=hours)
            cleaned_count = 0
            
            # ë©”ëª¨ë¦¬ì—ì„œ ì˜¤ë˜ëœ ì„¸ì…˜ ì œê±°
            expired_sessions = []
            for session_id, session_data in self.session_data.items():
                if session_data["last_activity"] < cutoff_time:
                    expired_sessions.append(session_id)
            
            for session_id in expired_sessions:
                # WebSocket ì—°ê²° ì •ë¦¬
                if session_id in self.active_connections:
                    del self.active_connections[session_id]
                
                del self.session_data[session_id]
                cleaned_count += 1
                logger.info(f"Cleaned up expired chat session: {session_id}")
            
            # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¹„í™œì„±í™”
            inactive_sessions = db.query(ChatSession).filter(
                ChatSession.status == 'active',
                ChatSession.started_at < cutoff_time
            ).all()
            for session in inactive_sessions:
                session.status = 'expired'
                session.ended_at = datetime.now()
                cleaned_count += 1
            
            if inactive_sessions:
                db.commit()
            
            return cleaned_count
            
        except Exception as e:
            logger.error(f"Error cleaning up chat sessions: {e}")
            db.rollback()
            raise
    
    # ===== AI Fortune Integration Methods =====
    
    async def _generate_ai_fortune_response(
        self, 
        db: Session, 
        fortune_type: str, 
        question: str, 
        user_data: Dict[str, Any],
        additional_info: Dict[str, Any],
        websocket: WebSocket = None
    ) -> Dict[str, Any]:
        """AIë¥¼ ì‚¬ìš©í•œ ìš´ì„¸ ìƒì„±"""
        try:
            from ..models.fortune import FortuneType
            
            # ìš´ì„¸ íƒ€ì… ë³€í™˜
            fortune_type_enum = None
            if fortune_type == "daily":
                fortune_type_enum = FortuneType.DAILY
            elif fortune_type == "tarot":
                fortune_type_enum = FortuneType.TAROT
            elif fortune_type == "zodiac":
                fortune_type_enum = FortuneType.ZODIAC
            elif fortune_type == "oriental":
                fortune_type_enum = FortuneType.ORIENTAL
            else:
                fortune_type_enum = FortuneType.DAILY
            
            # ì¶”ê°€ ë§¤ê°œë³€ìˆ˜ êµ¬ì„±
            additional_params = {}
            if fortune_type == "tarot":
                additional_params["question"] = question or "ì¼ë°˜ì ì¸ ìš´ì„¸ê°€ ê¶ê¸ˆí•´ìš”"
                additional_params["question_type"] = self._classify_question_type(question)
            elif fortune_type == "zodiac":
                additional_params["period"] = "daily"
            elif fortune_type == "oriental":
                additional_params.update({
                    "birth_date": additional_info.get("birth_date", user_data.get("birth_date")),
                    "birth_time": additional_info.get("birth_time", user_data.get("birth_time"))
                })
            
            # LLM í˜¸ì¶œ ìƒì„¸ ì •ë³´ ì „ì†¡
            if websocket:
                await self._send_to_websocket(websocket, {
                    "type": "llm_details",
                    "data": {
                        "message": f"Cerebras AIì— {fortune_type} ìš´ì„¸ ìš”ì²­ ì¤‘...",
                        "model": "llama3.1-8b",
                        "status": "requesting"
                    }
                })
            
            # AI ìš´ì„¸ ìƒì„±
            fortune_result = await self.fortune_service.get_ai_fortune(
                db=db,
                fortune_type=fortune_type_enum,
                user_data=user_data,
                additional_params=additional_params,
                force_regenerate=False
            )
            
            # LLM ì‘ë‹µ ì„±ê³µ ì•Œë¦¼ (ì‹¤ì œ ì‘ë‹µ ë‚´ìš© í¬í•¨)
            if websocket:
                # ìš´ì„¸ ë©”ì‹œì§€ ì¶”ì¶œ
                fortune_message = self._extract_fortune_message(fortune_result, fortune_type)
                await self._send_to_websocket(websocket, {
                    "type": "llm_response",
                    "data": {
                        "message": "Cerebras AI ì‘ë‹µ ë°›ìŒ!",
                        "response_length": len(str(fortune_result)),
                        "fortune_content": fortune_message,  # ì‹¤ì œ ìš´ì„¸ ë‚´ìš©
                        "full_result": fortune_result if len(str(fortune_result)) < 1000 else str(fortune_result)[:1000] + "...",
                        "status": "received"
                    }
                })
            
            logger.info(f"AI fortune generated successfully for type: {fortune_type}")
            return fortune_result
            
        except Exception as e:
            logger.error(f"AI fortune generation failed, falling back to legacy: {e}")
            return await self._generate_legacy_fortune_response(
                db, fortune_type, question, user_data, additional_info
            )
    
    async def _generate_legacy_fortune_response(
        self, 
        db: Session, 
        fortune_type: str, 
        question: str, 
        user_data: Dict[str, Any],
        additional_info: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ìš´ì„¸ ìƒì„± (í´ë°±)"""
        try:
            if fortune_type == "daily":
                return await self.fortune_service.get_daily_fortune(db, user_data)
            elif fortune_type == "tarot":
                from ..models.fortune import QuestionType
                question_type = self._classify_question_type_enum(question)
                return await self.fortune_service.get_tarot_fortune(
                    db, question or "ì¼ë°˜ì ì¸ ìš´ì„¸ê°€ ê¶ê¸ˆí•´ìš”", question_type, user_data
                )
            elif fortune_type == "zodiac":
                from ..models.fortune import ZodiacSign
                zodiac = additional_info.get("zodiac", "pisces")
                try:
                    zodiac_sign = ZodiacSign(zodiac)
                except ValueError:
                    zodiac_sign = ZodiacSign.PISCES
                return await self.fortune_service.get_zodiac_fortune(
                    db, zodiac_sign, "daily", user_data
                )
            elif fortune_type == "oriental":
                birth_data = {
                    "birth_date": additional_info.get("birth_date", "1990-01-01"),
                    "birth_time": additional_info.get("birth_time", "12:00")
                }
                return await self.fortune_service.get_oriental_fortune(
                    db, birth_data, user_data
                )
            else:
                return await self.fortune_service.get_daily_fortune(db, user_data)
                
        except Exception as e:
            logger.error(f"Legacy fortune generation also failed: {e}")
            raise
    
    def _classify_question_type(self, question: str) -> str:
        """ì§ˆë¬¸ì„ ë¶„ë¥˜í•˜ì—¬ íƒ€ì… ë°˜í™˜ (ë¬¸ìì—´)"""
        if not question:
            return "general"
        
        question_lower = question.lower()
        if any(word in question_lower for word in ["love", "ì—°ì• ", "ì‚¬ë‘", "ì• ì •", "ì§"]):
            return "love"
        elif any(word in question_lower for word in ["money", "ëˆ", "ì¬ë¬¼", "ê²½ì œ", "íˆ¬ì", "ëˆë²Œ", "ì¬ì •"]):
            return "money"
        elif any(word in question_lower for word in ["health", "ê±´ê°•", "ëª¸", "ì»¨ë””ì…˜", "ë³‘", "ì•„í”„"]):
            return "health"
        elif any(word in question_lower for word in ["work", "ì§ì¥", "ì—…ë¬´", "íšŒì‚¬", "ì‚¬ì—…", "ìŠ¹ì§„"]):
            return "work"
        elif any(word in question_lower for word in ["ì¼", "ìš´ì„¸"]):
            # 'ì¼'ë§Œìœ¼ë¡œëŠ” workë¡œ ë¶„ë¥˜í•˜ì§€ ì•Šê³ , ë” êµ¬ì²´ì ì¸ ì»¨í…ìŠ¤íŠ¸ê°€ í•„ìš”
            if any(work_word in question_lower for work_word in ["ì§ì¥", "ì—…ë¬´", "íšŒì‚¬", "ì‚¬ì—…"]):
                return "work"
            else:
                return "general"
        else:
            return "general"
    
    def _classify_question_type_enum(self, question: str):
        """ì§ˆë¬¸ì„ ë¶„ë¥˜í•˜ì—¬ QuestionType enum ë°˜í™˜"""
        from ..models.fortune import QuestionType
        
        question_type_str = self._classify_question_type(question)
        
        type_mapping = {
            "love": QuestionType.LOVE,
            "money": QuestionType.MONEY,
            "health": QuestionType.HEALTH,
            "work": QuestionType.WORK,
            "general": QuestionType.GENERAL
        }
        
        return type_mapping.get(question_type_str, QuestionType.GENERAL)
    
    def _extract_fortune_message(self, fortune_result: Dict[str, Any], fortune_type: str) -> str:
        """ìš´ì„¸ ê²°ê³¼ì—ì„œ TTSìš© ë©”ì‹œì§€ ì¶”ì¶œ"""
        try:
            logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] ìš´ì„¸ ê²°ê³¼ êµ¬ì¡°: {list(fortune_result.keys()) if isinstance(fortune_result, dict) else type(fortune_result)}")
            
            extracted_message = None
            
            # AI ìƒì„± ë©”ì‹œì§€ ìš°ì„  ì‚¬ìš©
            if "message" in fortune_result:
                extracted_message = fortune_result["message"]
                logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] 'message' í•„ë“œì—ì„œ ì¶”ì¶œ: {extracted_message[:100]}...")
            elif "overall" in fortune_result and "message" in fortune_result["overall"]:
                extracted_message = fortune_result["overall"]["message"]
                logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] 'overall.message' í•„ë“œì—ì„œ ì¶”ì¶œ: {extracted_message[:100]}...")
            elif "advice" in fortune_result and fortune_result["advice"]:
                extracted_message = fortune_result["advice"]
                logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] 'advice' í•„ë“œì—ì„œ ì¶”ì¶œ: {extracted_message[:100]}...")
            else:
                # ìš´ì„¸ íƒ€ì…ë³„ ê¸°ë³¸ ë©”ì‹œì§€
                default_messages = {
                    "daily": "ì˜¤ëŠ˜ í•˜ë£¨ë„ í–‰ìš´ì´ ê°€ë“í•˜ê¸¸ ë°”ë¼ìš”!",
                    "tarot": "íƒ€ë¡œ ì¹´ë“œê°€ ì „í•˜ëŠ” ë©”ì‹œì§€ë¥¼ ë§ˆìŒì— ìƒˆê²¨ë³´ì„¸ìš”.",
                    "zodiac": "ë³„ìë¦¬ì˜ ê¸°ìš´ì´ ë‹¹ì‹ ê³¼ í•¨ê»˜ í•©ë‹ˆë‹¤.",
                    "oriental": "ì‚¬ì£¼ì— ë‚˜íƒ€ë‚œ ìš´ëª…ì˜ íë¦„ì„ ëŠê»´ë³´ì„¸ìš”."
                }
                extracted_message = default_messages.get(fortune_type, "ìš´ì„¸ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”!")
                logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] ê¸°ë³¸ ë©”ì‹œì§€ ì‚¬ìš©: {extracted_message}")
                
            logger.info(f"[ë©”ì‹œì§€ ì¶”ì¶œ] ìµœì¢… ì¶”ì¶œëœ ë©”ì‹œì§€: {extracted_message[:200]}...")
            return extracted_message
                
        except Exception as e:
            logger.error(f"Error extracting fortune message: {e}")
            return "ìš´ì„¸ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”!"